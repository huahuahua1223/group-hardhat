# 群聊方案需求设计

# 1) 总体目标与边界

- **资产分层与名单**：完全**链下**计算（CSV/DB），把“可进大群的地址与其资产档位”等做成**默克尔树**；合约**只存 Merkle Root**。校验使用 OpenZeppelin `MerkleProof`。([OpenZeppelin Docs](https://docs.openzeppelin.com/contracts/4.x/utilities?utm_source=chatgpt.com "Utilities"))

- **用户体验**：在 dApp 里，用户**未与合约交互前**，若在名单中，前端能显示“**你有资格加入**”（离线验证或 `view` 读合约均可），用户**自愿点击**再上链完成入群绑定。

- **群聊**：仍保持“大群（Community）/小群（Room）”结构；**小群创建费固定 50 UNICHAT**；**拉人费由小群群主自定义**。拉人从邀请人地址扣费，支持 `permit()` 的代币则可“一笔授权+扣费”。([Revoke.cash](https://revoke.cash/learn/approvals/what-are-eip2612-permit-signatures?utm_source=chatgpt.com "What Are EIP2612 Permit Signatures?"))

- **消息**：**明文通道默认开启**；消息既可**发事件**（便宜、便于索引），也可**写入合约状态**以便链上回读（但注意存储成本更高，事件数据**不能被合约读取**）。([Ethereum Stack Exchange](https://ethereum.stackexchange.com/questions/103128/why-cant-smart-contracts-access-events?utm_source=chatgpt.com "Why can't smart contracts access events"))

---

# 2) 角色与权限

- **系统管理员**：在工厂创建大群并**指定大群群主**；可设置全局参数（创建费、是否启用克隆、风险上限等）。

- **大群群主（Community Owner）**：管理本群参数（例如是否允许新小群、消息限制等）、**更新 Merkle Root** 与 epoch；不直接点名单（名单由链下生成）。

- **小群群主（Room Owner）**：任何**已加入大群**的地址都能创建；可设**拉人费**、消息策略等。

- 建议用 OpenZeppelin `AccessControl/Ownable` 管理。

---

# 3) 大群进群：默克尔树流程（核心）

## 3.1 链下产物

- 由你的链下服务产出：
  
  - **叶子编码**（建议）：`leaf = keccak256(abi.encodePacked(community, epoch, account, maxTier, validUntil, nonce))`
    
    - 含 `community` 与 `epoch`：防跨群/跨版本复用；
    
    - 含 `account`：绑定用户；
    
    - 可选 `maxTier/validUntil/nonce`：表示最高资产档位、过期时间、防重放等（字段可按你需要精简）。
  
  - **Merkle Root** 与 **proof**（每个地址一段 proof）。
  
  - 可提供一个 `metadataURI`（比如 CID），让前端取回 proof 或 UI 展示版本说明。

> 说明：校验基于 `MerkleProof.verify(proof, root, leaf)`；proof 是从叶到根的兄弟哈希数组。([OpenZeppelin Docs](https://docs.openzeppelin.com/contracts/4.x/utilities?utm_source=chatgpt.com "Utilities"))

## 3.2 合约仅存根与 epoch

- **`rootEpoch`**（uint256）：当前启用的默克尔版本号；

- **`merkleRoot[rootEpoch]`**（bytes32）：当前根；更新根时 **epoch 自增** 并发事件 `MerkleRootUpdated(epoch, root, uri)`（仅大群群主）。

- 可选 **启用时间窗**（validFrom/validUntil）以滚动换根。

## 3.3 “可见但未加入”的 UX

- 前端拿到**链下 proof**，用链下库或合约 `view` 辅助函数 `eligible(account, maxTier, epoch, proof)` 做**只读验证**；

- 若返回 `true`，UI 显示“你有资格加入本大群（最高档位：X）→ **点此上链加入**”。

- 用户点击后调用 `joinCommunity(maxTier, epoch, proof)` 执行**状态变更**，把 `msg.sender` 记为成员并存储其档位。

> 注：只读验证不消耗 gas；真正入群写状态才上链。

## 3.4 入群与版本一致性

- **状态落盘**：`isMember[address] = true; memberTier[address] = maxTier; lastJoinedEpoch[address] = epoch;`

- **函数访问**（如创建/加入小群、发消息）检查 `lastJoinedEpoch == currentEpoch`；若根已换，用户需**用新 proof 重新 join** 以对齐版本。

---

# 4) 小群（Room）与经济

- **创建**：仅**大群成员**可创建；**固定创建费 50 UNICHAT**（由创建者支付给协议金库/工厂）。

- **拉人费**：由**小群群主**自定义（可配全局/社区上限以防误设）。

- **扣费与优化**：走 `ERC20.transferFrom`；若 UNICHAT 支持 **EIP-2612 permit**，提供 `inviteWithPermit` 以“一笔授权+扣费”。([Revoke.cash](https://revoke.cash/learn/approvals/what-are-eip2612-permit-signatures?utm_source=chatgpt.com "What Are EIP2612 Permit Signatures?"))

- **大规模开房**：采用 **EIP-1167 Minimal Proxy** 克隆 `Room` 实例，显著降低部署 gas。([Ethereum Improvement Proposals](https://eips.ethereum.org/EIPS/eip-1167?utm_source=chatgpt.com "ERC-1167: Minimal Proxy Contract"))

---

# 5) 消息模型（事件 + 状态存储，明文默认开）

- **事件**（推荐基线，便宜易索引）：  
  `event MessageBroadcasted(room, sender, kind, indexed seq, bytes32 contentHash, string cid, bool persisted, uint40 ts)`
  
  > 注意：**事件数据合约不可读**，仅供链下读取/索引。([Ethereum Stack Exchange](https://ethereum.stackexchange.com/questions/103128/why-cant-smart-contracts-access-events?utm_source=chatgpt.com "Why can't smart contracts access events"))

- **状态存储**（可开关）：
  
  - `struct Message { address sender; uint40 ts; uint8 kind; bytes content; }`
  
  - 提供分页读取（如 `getMessage(page, idx)`）以控制 gas。
  
  - 建议限制 `messageMaxBytes`（如 ≤ 1KB）与**发送速率**。

- **明文**：`plaintextEnabled = true`（默认）；

- **密文**：内容在链下加密，上链只存密文/哈希/CID；群密钥轮换沿用之前设计（成员变更 → `groupKeyEpoch++` → `GroupKeyEpochIncreased` 事件）。

---

# 6) 合约拆分与关键接口（草案）

## 6.1 `CommunityFactory`

- 只读：`unichatToken()`, `roomCreateFee()`（= 50e18）

- 管理员：`createCommunity(owner, options)` → `community`

- 事件：`CommunityCreated(community, owner)`

## 6.2 `Community`

- **Merkle 管理**
  
  - `setMerkleRoot(bytes32 newRoot, string calldata uri)`（onlyOwner：内部 `rootEpoch++` 并记录 `merkleRoot[rootEpoch] = newRoot`）
  
  - 事件：`MerkleRootUpdated(uint256 epoch, bytes32 root, string uri)`

- **资格检测（只读）**
  
  - `eligible(address account, uint256 maxTier, uint256 epoch, bytes32[] calldata proof) view returns (bool)`（辅助 UI）

- **加入大群（写状态）**
  
  - `joinCommunity(uint256 maxTier, uint256 epoch, bytes32[] calldata proof)`
    
    - 内部计算 `leaf = keccak256(abi.encodePacked(address(this), epoch, msg.sender, maxTier, validUntil?, nonce?))` 并 `MerkleProof.verify`；通过即登记成员与档位；
    
    - 事件：`Joined(address account, uint256 tier, uint256 epoch)`

- **小群创建入口**
  
  - `createRoom(RoomInit params)`：`require isMember[msg.sender] && lastJoinedEpoch[msg.sender] == currentEpoch`；从调用者扣 **50 UNICHAT**；部署 `Room`（1167 克隆）。
  
  - 事件：`RoomCreated(room, owner, inviteFee)`

## 6.3 `Room`

- **成员与费用**
  
  - `setInviteFee(uint256 fee)`（onlyOwner；可设上限）
  
  - `invite(address user, PayParams)`（从邀请人扣 `inviteFee`，支持 `permit`）
  
  - `kick(address user)` / `leave()` → **`groupKeyEpoch++`** & `emit GroupKeyEpochIncreased(epoch, metadataHash)`（可带新密钥分发清单哈希）

- **消息**
  
  - `sendMessage(uint8 kind, bytes content, bool persist, string cid)`（含长度/频率校验）
  
  - 事件：`MessageBroadcasted(...)`

- **查询**
  
  - `messageCount()`、`getMessage(page, idx)` 等分页只读

---

# 7) 前端/后端对接要点

- **Proof 获取**：前端用钱包地址向你的后端请求 proof（或从 `metadataURI` 下载）；

- **“可见但未加入”**：
  
  - 方案 A（离线验证）：前端用 JS 库对 `proof` + 链上 `root` 验证后展示“可加入”；
  
  - 方案 B（链上只读）：调用 `eligible(...)` 得到 `true/false` 再展示。

- **正式加入**：点击触发 `joinCommunity(...)` 写状态；之后才能创建/加入小群与发言。

- **索引与读取**：事件用于快速索引；如开启状态存储，则前端也可直连只读接口拉全量。

---

# 8) 风控与治理建议

- **Proof 过期**：`validUntil`（可选）+ 换根 `epoch` 保证名单滚动更新；

- **邀请费上限**：在 Factory/Community 层加入 `maxInviteFee`（可选）；

- **消息限流**：按地址/房间设置时间窗速率与单条字节上限；

- **克隆安全**：用 **EIP-1167** 标准克隆，初始化参数在构造/初始化函数中一次性设置。([Ethereum Improvement Proposals](https://eips.ethereum.org/EIPS/eip-1167?utm_source=chatgpt.com "ERC-1167: Minimal Proxy Contract"))
